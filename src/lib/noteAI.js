// src/lib/noteAI.js
// ✅ AI Note Analysis — calls Supabase Edge Function (server-side Claude API)
// ✅ Respects usage limits via consumeAiUsage + incrementUsage
// ✅ Falls back to client-side mock when Edge Function is unavailable
// ✅ Stores results in notes.ai_payload column

import { supabase, isSupabaseConfigured } from "./supabaseClient";
import { consumeAiUsage } from "./usage";

const NOTES_TABLE = "notes";
const MIN_CHARS_FOR_AUTO = 20; // auto-analyze threshold
const COOLDOWN_MS = 30_000; // 30s cooldown between auto-analyses on same note

// In-memory cooldown tracker (noteId -> timestamp)
const lastAnalyzed = new Map();

/**
 * Check if a note qualifies for auto-analysis
 */
export function shouldAutoAnalyze(noteBody, noteId) {
  if (!noteBody || noteBody.trim().length < MIN_CHARS_FOR_AUTO) return false;

  // Cooldown: don't re-analyze within 30s
  const last = lastAnalyzed.get(noteId);
  if (last && Date.now() - last < COOLDOWN_MS) return false;

  return true;
}

/**
 * Main analysis function
 * @param {object} params
 * @param {string} params.noteId - Note ID
 * @param {string} params.userId - User ID
 * @param {string} params.title - Note title
 * @param {string} params.body - Note body text
 * @param {function} params.incrementUsage - From useSubscription hook
 * @param {boolean} params.isManual - Whether user explicitly requested it
 * @returns {object|null} Analysis result or null if failed/limited
 */
export async function analyzeNote({
  noteId,
  userId,
  title,
  body,
  incrementUsage,
  isManual = false,
}) {
  if (!body || body.trim().length < MIN_CHARS_FOR_AUTO) {
    return null;
  }

  const supabaseReady =
    typeof isSupabaseConfigured === "function"
      ? isSupabaseConfigured()
      : !!isSupabaseConfigured;

  // ── 1. Check & consume usage limits ──
  if (supabaseReady && supabase && userId) {
    try {
      const usageRes = await consumeAiUsage(userId, "aiSummaries", 1);
      if (!usageRes?.success) {
        return {
          error: true,
          limitReached: true,
          message: "Daily AI limit reached. Try again tomorrow or upgrade to Pro.",
        };
      }
    } catch (err) {
      console.warn("Usage check failed (proceeding anyway):", err);
    }
  }

  // ── 2. Call Edge Function (or fallback) ──
  let analysis;

  try {
    analysis = await callEdgeFunction({ title, body });
  } catch (err) {
    console.warn("Edge Function unavailable, using local analysis:", err);
    analysis = generateLocalAnalysis({ title, body });
  }

  const now = new Date().toISOString();

  const aiPayload = {
    summary: analysis.summary || null,
    keyPoints: analysis.keyPoints || [],
    sentiment: analysis.sentiment || null,
    actionItems: analysis.actionItems || [],
    topics: analysis.topics || [],
    wordCount: (body || "").split(/\s+/).filter(Boolean).length,
    SmartTasks: (analysis.actionItems || []).map((item, i) => ({
      id: `task-${i}`,
      text: item,
      done: false,
    })),
    SmartHighlights: analysis.keyPoints || [],
    SmartSchedule: null,
    generatedAt: now,
    model: analysis.model || "local-analysis",
    isAutoGenerated: !isManual,
  };

  // ── 3. Persist to DB ──
  if (supabaseReady && supabase && userId && noteId) {
    try {
      await supabase
        .from(NOTES_TABLE)
        .update({
          ai_payload: aiPayload,
          ai_generated_at: now,
          ai_model: aiPayload.model,
        })
        .eq("id", noteId)
        .eq("user_id", userId);
    } catch (err) {
      console.warn("Failed to persist AI payload:", err);
    }
  }

  // ── 4. Track usage ──
  if (typeof incrementUsage === "function") {
    try {
      await incrementUsage("aiSummaries");
    } catch {
      // non-blocking
    }
  }

  // ── 5. Increment AI uses in stats ──
  if (supabaseReady && supabase && userId) {
    try {
      await supabase.rpc("increment_ai_uses", {
        p_user_id: userId,
        p_amount: 1,
      });

      window.dispatchEvent(
        new CustomEvent("notestream:ai_uses_updated", {
          detail: { increment: 1 },
        })
      );
    } catch {
      // non-blocking
    }

    // Log activity
    try {
      await supabase.rpc("log_activity_event", {
        p_user_id: userId,
        p_event_type: "ai_summary",
        p_title: `AI analyzed note: ${(title || "Untitled").slice(0, 50)}`,
        p_metadata: {
          note_id: noteId,
          auto: !isManual,
          word_count: aiPayload.wordCount,
        },
      });
    } catch {
      // non-blocking
    }
  }

  // Update cooldown tracker
  lastAnalyzed.set(noteId, Date.now());

  return aiPayload;
}

/**
 * Call Supabase Edge Function (keeps API key server-side)
 */
async function callEdgeFunction({ title, body }) {
  if (!supabase) throw new Error("Supabase not configured");

  const { data, error } = await supabase.functions.invoke("analyze-note", {
    body: JSON.stringify({
      title: title || "Untitled",
      body: body || "",
    }),
  });

  if (error) throw error;
  if (!data) throw new Error("Empty response from Edge Function");

  return data;
}

/**
 * Local analysis fallback (no API key needed)
 * Provides useful analysis using text processing heuristics
 */
function generateLocalAnalysis({ title, body }) {
  const text = `${title || ""} ${body || ""}`.trim();
  const words = text.split(/\s+/).filter(Boolean);
  const sentences = text.split(/[.!?]+/).filter((s) => s.trim().length > 5);
  const wordCount = words.length;

  // ── Extract key sentences (simple extractive summary) ──
  const sentenceScores = sentences.map((s) => {
    const trimmed = s.trim();
    let score = 0;

    // Longer sentences tend to be more informative
    score += Math.min(trimmed.split(/\s+/).length / 5, 3);

    // Sentences with key indicator words score higher
    const indicators = [
      "important", "key", "main", "critical", "need", "must",
      "should", "deadline", "priority", "goal", "objective",
      "decision", "action", "plan", "strategy", "result",
      "budget", "cost", "revenue", "timeline", "milestone",
    ];
    for (const ind of indicators) {
      if (trimmed.toLowerCase().includes(ind)) score += 2;
    }

    // First and last sentences are often more important
    const idx = sentences.indexOf(s);
    if (idx === 0) score += 2;
    if (idx === sentences.length - 1) score += 1;

    return { text: trimmed, score };
  });

  sentenceScores.sort((a, b) => b.score - a.score);

  // Summary: top 3 sentences, re-ordered by original position
  const topSentences = sentenceScores.slice(0, 3);
  const summary = topSentences
    .sort(
      (a, b) =>
        sentences.findIndex((s) => s.trim() === a.text) -
        sentences.findIndex((s) => s.trim() === b.text)
    )
    .map((s) => s.text)
    .join(". ")
    .replace(/\.+/g, ".") + (topSentences.length > 0 ? "." : "");

  // ── Key points ──
  const keyPoints = sentenceScores
    .slice(0, 5)
    .map((s) => s.text)
    .filter((s) => s.length > 10);

  // ── Action items (look for imperative/task-like sentences) ──
  const actionPatterns = [
    /\b(need to|should|must|have to|required to|make sure|ensure|follow up|complete|submit|send|review|prepare|schedule|organize|update|create|build|fix|resolve)\b/i,
    /\b(todo|to-do|action item|next step|deliverable)\b/i,
    /^[-•*]\s+/,
  ];

  const actionItems = sentences
    .filter((s) =>
      actionPatterns.some((pattern) => pattern.test(s.trim()))
    )
    .map((s) => s.trim())
    .slice(0, 5);

  // ── Sentiment (simple keyword approach) ──
  const positiveWords = [
    "good", "great", "excellent", "success", "happy", "improve",
    "growth", "positive", "progress", "achieve", "win", "exciting",
  ];
  const negativeWords = [
    "bad", "issue", "problem", "risk", "concern", "delay",
    "fail", "difficult", "challenge", "blocker", "miss", "worried",
  ];

  const lower = text.toLowerCase();
  let posCount = 0;
  let negCount = 0;
  for (const w of positiveWords) if (lower.includes(w)) posCount++;
  for (const w of negativeWords) if (lower.includes(w)) negCount++;

  let sentiment = "neutral";
  if (posCount > negCount + 1) sentiment = "positive";
  else if (negCount > posCount + 1) sentiment = "negative";
  else if (posCount > 0 && negCount > 0) sentiment = "mixed";

  // ── Topics (extract frequent meaningful words) ──
  const stopWords = new Set([
    "the", "a", "an", "is", "are", "was", "were", "be", "been",
    "being", "have", "has", "had", "do", "does", "did", "will",
    "would", "could", "should", "may", "might", "can", "shall",
    "to", "of", "in", "for", "on", "with", "at", "by", "from",
    "as", "into", "through", "during", "before", "after", "about",
    "between", "this", "that", "these", "those", "it", "its",
    "and", "but", "or", "nor", "not", "so", "if", "than", "then",
    "i", "we", "you", "he", "she", "they", "me", "him", "her",
    "us", "them", "my", "your", "his", "our", "their",
  ]);

  const freq = {};
  for (const w of words) {
    const clean = w.toLowerCase().replace(/[^a-z0-9]/g, "");
    if (clean.length > 3 && !stopWords.has(clean)) {
      freq[clean] = (freq[clean] || 0) + 1;
    }
  }

  const topics = Object.entries(freq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 6)
    .map(([word]) => word);

  return {
    summary: summary || `Note with ${wordCount} words about ${topics.slice(0, 3).join(", ") || "various topics"}.`,
    keyPoints: keyPoints.length > 0 ? keyPoints : [`This note contains ${wordCount} words across ${sentences.length} sentences.`],
    actionItems,
    sentiment,
    topics,
    model: "notestream-local-v1",
  };
}