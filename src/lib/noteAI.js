// src/lib/noteAI.js
// ✅ AI Note Analysis — Supabase Edge Function (server-side AI)
// ✅ Single authoritative usage check via consumeAiUsage (daily_usage + plan limits)
// ✅ Graceful fallback to local analysis when AI provider unavailable
// ✅ Persists ai_payload to notes table

import { supabase, isSupabaseConfigured } from "./supabaseClient";
import { consumeAiUsage } from "./usage";

const NOTES_TABLE = "notes";
const MIN_CHARS_FOR_AUTO = 20;
const COOLDOWN_MS = 30_000;

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// In-memory cooldown tracker (noteId -> timestamp)
const lastAnalyzed = new Map();

export function shouldAutoAnalyze(noteBody, noteId) {
  if (!noteBody || noteBody.trim().length < MIN_CHARS_FOR_AUTO) return false;

  const last = lastAnalyzed.get(noteId);
  if (last && Date.now() - last < COOLDOWN_MS) return false;

  return true;
}

export async function analyzeNote({ noteId, userId, title, body, isManual = false }) {
  if (!body || body.trim().length < MIN_CHARS_FOR_AUTO) return null;

  const supabaseReady =
    typeof isSupabaseConfigured === "function"
      ? isSupabaseConfigured()
      : !!isSupabaseConfigured;

  // 1) Enforce usage limits (single source of truth)
  if (supabaseReady && supabase && userId) {
    try {
      const usageRes = await consumeAiUsage(userId, "ai_summaries", 1);

      if (!usageRes?.success) {
        return {
          error: true,
          limitReached: true,
          message: "Daily AI limit reached. Upgrade to continue.",
        };
      }
    } catch (err) {
      console.warn("Usage check failed (continuing):", err);
    }
  }

  // 2) Run analysis (Edge → fallback)
  let raw;
  try {
    raw = await callEdgeFunction({ title, body });
  } catch (err) {
    console.warn("Edge unavailable, using local analysis:", err);
    raw = generateLocalAnalysis({ title, body });
  }

  // 3) Normalize result shape
  const analysis = normalizeAnalysis(raw);
  const now = new Date().toISOString();

  const aiPayload = {
    summary: analysis.summary || null,
    keyPoints: analysis.keyPoints || [],
    actionItems: analysis.actionItems || [],
    sentiment: analysis.sentiment || "neutral",
    topics: analysis.topics || [],
    SmartHighlights: analysis.keyPoints || [],
    SmartTasks: (analysis.actionItems || []).map((text, i) => ({
      id: `task-${i}`,
      text,
      done: false,
    })),
    SmartSchedule: analysis.SmartSchedule ?? null,
    wordCount: (body || "").split(/\s+/).filter(Boolean).length,
    generatedAt: now,
    model: analysis.model || "local-analysis",
    isAutoGenerated: !isManual,
  };

  // 4) Persist to DB
  if (supabaseReady && supabase && userId && noteId) {
    try {
      await supabase
        .from(NOTES_TABLE)
        .update({
          ai_payload: aiPayload,
          ai_generated_at: now,
          ai_model: aiPayload.model,
        })
        .eq("id", noteId)
        .eq("user_id", userId);
    } catch (err) {
      console.warn("Failed to persist AI payload:", err);
    }

    // Activity log (non-blocking)
    try {
      await supabase.rpc("log_activity_event", {
        p_user_id: userId,
        p_event_type: "ai_summary",
        p_title: `AI analyzed note: ${(title || "Untitled").slice(0, 50)}`,
        p_metadata: {
          note_id: noteId,
          auto: !isManual,
          word_count: aiPayload.wordCount,
          model: aiPayload.model,
        },
      });
    } catch {}
  }

  lastAnalyzed.set(noteId, Date.now());
  return aiPayload;
}

// ✅ Plain fetch() to bypass Supabase JS SDK adding x-supabase-client-platform header
async function callEdgeFunction({ title, body }) {
  if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
    throw new Error("Supabase not configured");
  }

  // Get a valid auth token
  let authToken = null;
  if (supabase) {
    try {
      // Try getSession first
      const { data: { session } } = await supabase.auth.getSession();
      if (session?.access_token) {
        authToken = session.access_token;
      }
    } catch {
      // ignore
    }

    // If no session, try refreshing
    if (!authToken) {
      try {
        const { data: { session } } = await supabase.auth.refreshSession();
        if (session?.access_token) {
          authToken = session.access_token;
        }
      } catch {
        // ignore
      }
    }
  }

  // Fall back to anon key only if no user token available
  if (!authToken) {
    authToken = SUPABASE_ANON_KEY;
  }

  const response = await fetch(
    `${SUPABASE_URL}/functions/v1/analyze-note`,
    {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${authToken}`,
        "Content-Type": "application/json",
        "apikey": SUPABASE_ANON_KEY,
      },
      body: JSON.stringify({
        title: title || "Untitled",
        body: body || "",
      }),
    }
  );

  if (!response.ok) {
    const errText = await response.text().catch(() => "Unknown error");
    throw new Error(`Edge function failed (${response.status}): ${errText}`);
  }

  const data = await response.json();

  if (!data) throw new Error("Empty response from Edge Function");
  if (data.fallback) throw new Error(data.error || "AI unavailable");

  return data;
}

function normalizeAnalysis(data) {
  const smartHighlights = Array.isArray(data?.SmartHighlights) ? data.SmartHighlights : null;
  const smartTasks = Array.isArray(data?.SmartTasks) ? data.SmartTasks : null;

  const keyPoints =
    smartHighlights ||
    (Array.isArray(data?.keyPoints) ? data.keyPoints : []) ||
    [];

  const actionItems =
    (smartTasks
      ? smartTasks.map((t) => (typeof t === "string" ? t : t?.text)).filter(Boolean)
      : null) ||
    (Array.isArray(data?.actionItems) ? data.actionItems : []) ||
    [];

  return {
    summary: data?.summary || "",
    keyPoints,
    actionItems,
    SmartSchedule: data?.SmartSchedule ?? null,
    sentiment: data?.sentiment || "neutral",
    topics: Array.isArray(data?.topics) ? data.topics : [],
    model: data?.model || "local-analysis",
  };
}

function generateLocalAnalysis({ title, body }) {
  const text = `${title || ""} ${body || ""}`.trim();
  const words = text.split(/\s+/).filter(Boolean);
  const sentences = text.split(/[.!?]+/).map((s) => s.trim()).filter((s) => s.length > 5);

  const summary = (sentences.slice(0, 3).join(". ") + (sentences.length ? "." : "")).trim();
  const keyPoints = sentences.slice(0, 5);

  const actionItems = sentences
    .filter((s) => /\b(need to|should|must|todo|action|next step|follow up|fix|review|send|submit)\b/i.test(s))
    .slice(0, 6);

  return {
    summary,
    keyPoints,
    actionItems,
    sentiment: "neutral",
    topics: words.slice(0, 8).map((w) => w.toLowerCase()),
    model: "notestream-local-v1",
  };
}